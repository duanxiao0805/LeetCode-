![image](https://user-images.githubusercontent.com/62934005/126598536-5a6734c8-7713-4f33-81ed-cf640ad0cf36.png)


这个题,做了好久,现在差不多明白思路了,跟反转链表的思路相似


先图解一下:

![image](https://user-images.githubusercontent.com/62934005/126598688-1ca94524-296d-432a-9a4d-8b4862ed17c3.png)
![image](https://user-images.githubusercontent.com/62934005/126598719-c389d8d2-4360-46b5-94ef-0e1b91d32048.png)
![image](https://user-images.githubusercontent.com/62934005/126598729-5d96c9b2-af5c-482c-8585-ffdd00a2018c.png)


**遇到的问题**

第一步和第二步实现的时候,顺序的问题?

如果反过来实现,那么s的指向就已经改变了!



**代码实现**

```java
class Solution {
    public ListNode swapPairs(ListNode head) {
        //设置一个新结点
        ListNode dummy=new ListNode();
        dummy.next=head;
        ListNode pre=dummy;

        while(pre.next!=null&&pre.next.next!=null){
            //这个地方是怎么推断出来的???
            ListNode f=pre.next;
            ListNode s=f.next;

            //第一步
            f.next=s.next;
            //第二步
            s.next=f;

            //第一步和第二步不能反过来!!!
            //反过来的话,s的next早就改变了,不是原来初始的!!!

            //第三步pre指向s
            pre.next=s;

            //更新位置
            pre=f;

        }
        return dummy.next;
    }
}
```
